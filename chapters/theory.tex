\vspace{21.5pt}

\hypertarget{aineisto-ja-menetelmuxe4t}{%
\section{Aineisto ja menetelmät}\label{aineisto-ja-menetelmuxe4t}}

Keskeisten käsitteiden esittely

\hypertarget{domain-driven-design}{%
\subsection{Domain Driven Design}\label{domain-driven-design}}

(Sovellusalakeskeinen suunnittelu) (Liiketoimintavetoinen suunnittelu)

\hypertarget{knowledge-crunching}{%
\subsubsection{Knowledge crunching}\label{knowledge-crunching}}

\hypertarget{ubiquitous-language}{%
\subsubsection{Ubiquitous Language}\label{ubiquitous-language}}

\hypertarget{mallin-ilmaiseminen-ohjelmistossa}{%
\subsubsection{Mallin ilmaiseminen
ohjelmistossa}\label{mallin-ilmaiseminen-ohjelmistossa}}

\begin{itemize}
\tightlist
\item
  Domain-malli on ohjelmistossa omana erillisenä kerroksenaan, puhtaasti
  ja erillään muista.
\item
  Entity - entiteetti, eli olio, jolla on identiteetti
\item
  Assosiaatio, eli kulkusuunta
\end{itemize}

Pohdintaa: - Evans suosittaa kerroksittaista arkkitehtuuria, ja
erillistä kerrosta, jossa Domain-malli elää. Luonteva paikka tälle voisi
olla GraphQL-rajapinnan takana.

\hypertarget{graphql}{%
\subsection{GraphQL}\label{graphql}}

\hypertarget{tyyppijuxe4rjestelmuxe4}{%
\subsubsection{Tyyppijärjestelmä}\label{tyyppijuxe4rjestelmuxe4}}

GraphQL-rajapinta koostuu tyypeistä, ja niitä edustavista
olio-ilmentymistä.

Oheisessa esimerkissä näytetään tyyppien, ja sitä myötä olioiden väliset
suhteet. ConsolidatedInvoice-tyyppisessä oliossa on sisällä
invoices-kenttä, joka on lista Invoice-tyyppisiä olioita.

\begin{verbatim}
type Query {
  consolidatedInvoices [ConsolidatedInvoice]
}

Type Invoice {
  number: Int
  sum: Float
  date: Date
}

type ConsolidatedInvoice {
  number: Int
  invoices: [Invoice]
}
\end{verbatim}

\hypertarget{query-ja-mutation}{%
\subsubsection{Query ja Mutation}\label{query-ja-mutation}}

Rajapintaan voi tehdä kyselyjä Query-tyyppisen juuriolion kautta. Tämän
olion kentät vastaavat käytännössä niitä kyselyitä, joita rajapintaan
voi tehdä. Kentät ovat ikäänkuin sisäänmenoaukkoja, joiden kautta
oliorakenteita voi pyytää.

Kun oheisen esimerkin mukaisesti määritellystä GraphQL-rajapinnasta
halutaan pyytää tietoja, tehdään kysely, joka kuvaa halutun oliopuun
rakenteen tyyppien avulla:

\begin{verbatim}
{
  ConsolidatedInvoice {
    number
    invoices {
      number
      sum
    }
  }
}
\end{verbatim}

Kyselyssä määritellään kentät, jotka palautuvassa datassa halutaan
nähdä. Näin myös oliopuun syvyyttä voidaan kontrolloida. Oheisessa
esimerkissä voidaan hakea paitsi lista koontilaskuista, haluttaessa myös
jokaisen koontilaskun alle lista siihen kuuluvista laskuista.

Mutation - toiminto datan muuntelemiseen. Myös tämä palauttaa dataa

\hypertarget{skeema}{%
\subsubsection{Skeema}\label{skeema}}

Rajapinnan tyypit, niille tehtävät kyselyt ja mutaatiot kuvataan
skeemassa, GraphQL-kielen avulla.

-Pohdintaa: Tämä skeema on varmaankin keskeinen nivelkohta Domain Driven
Designin kanssa.
