\vspace{21.5pt}

\hypertarget{aineisto-ja-menetelmuxe4t}{%
\section{Aineisto ja menetelmät}\label{aineisto-ja-menetelmuxe4t}}

Keskeisten käsitteiden esittely

\hypertarget{domain-driven-design}{%
\subsection{Domain Driven Design}\label{domain-driven-design}}

(Sovellusalakeskeinen suunnittelu) (Liiketoimintavetoinen suunnittelu)

\hypertarget{knowledge-crunching}{%
\subsubsection{Knowledge crunching}\label{knowledge-crunching}}

\hypertarget{ubiquitous-language}{%
\subsubsection{Ubiquitous Language}\label{ubiquitous-language}}

\hypertarget{mallin-ilmaiseminen-ohjelmistossa}{%
\subsubsection{Mallin ilmaiseminen
ohjelmistossa}\label{mallin-ilmaiseminen-ohjelmistossa}}

\begin{itemize}
\tightlist
\item
  Domain-malli on ohjelmistossa omana erillisenä kerroksenaan, puhtaasti
  ja erillään muista.
\item
  Entity - entiteetti, eli olio, jolla on identiteetti
\item
  Assosiaatio, eli kulkusuunta
\end{itemize}

Pohdintaa: - Evans suosittaa kerroksittaista arkkitehtuuria, ja
erillistä kerrosta, jossa Domain-malli elää. Luonteva paikka tälle voisi
olla GraphQL-rajapinnan takana.

\hypertarget{graphql}{%
\subsection{GraphQL}\label{graphql}}

\hypertarget{tyyppijuxe4rjestelmuxe4}{%
\subsubsection{Tyyppijärjestelmä}\label{tyyppijuxe4rjestelmuxe4}}

GraphQL-rajapinta koostuu tyypeistä

\hypertarget{query-ja-mutation}{%
\subsubsection{Query ja Mutation}\label{query-ja-mutation}}

Rajapintaan voi tehdä queryjä - nämä ovat ikäänkuin sisäänmenoaukkoja,
joiden kautta oliorakenteita voi pyytää Mutation - toiminto datan
muuntelemiseen. Myös tämä palauttaa dataa

\hypertarget{skeema}{%
\subsubsection{Skeema}\label{skeema}}

Rajapinnan tyypit, niille tehtävät kyselyt ja mutaatiot kuvataan
skeemassa, GraphQL-kielen avulla.

-Pohdintaa: Tämä skeema on varmaankin keskeinen nivelkohta Domain Driven
Designin kanssa.
