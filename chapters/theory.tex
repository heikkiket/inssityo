\vspace{21.5pt}

\hypertarget{aineisto-ja-menetelmuxe4t}{%
\section{Aineisto ja menetelmät}\label{aineisto-ja-menetelmuxe4t}}

Keskeisten käsitteiden esittely

\hypertarget{section}{%
\subsection{\texorpdfstring{\gls{ddd}}{}}\label{section}}

(Sovellusalakeskeinen suunnittelu) (Liiketoimintavetoinen suunnittelu)

\gls{crunching} (Knowledge crunching) on keskeinen väline
sovellusaluemallin rakentamiseen. Evans kuvaa prosessin, jossa
kehittäjät luonnostelevat yhdessä sovellusalueen asiantuntijoiden kanssa
\gls{domainmodel}. Malli kytketään tiiviisti yhteen toteutuksen kanssa
tekemällä vuoroin suunnittelua, vuoroin ohjelmistokehitystä.
\cite[p. 13]{evans:ddd}

Tavoitteena on, että ohjelmistokehittäjien ja alan asiantuntijoiden
välille rakentuu \gls{ubilang}, jonka avulla kaikkien on mahdollista
yhteisesti keskustella ohjelmiston toiminnasta ja kehitystarpeista.
Tämän kielen käsitteet elävät ohjelmakoodissa, ja muodostavat koodin
ytimessä sijaitsevan \gls{domainlayer}

\hypertarget{n-rakennuspalikat}{%
\subsubsection{\texorpdfstring{\gls{ddd}n
rakennuspalikat}{n rakennuspalikat}}\label{n-rakennuspalikat}}

Eric Evans tarjoaa kirjassaan joukon käteviä työkaluja, joiden avulla
\gls{domainmodel} on mahdollista toteuttaa teknisesti.

\gls{entity} edustaa käytännössä kaikkea, jolla on identiteetti.
Esimerkiksi kahdella ihmisellä voi olla sama nimi, mutta he ovat silti
identiteetiltään eri henkilöitä. Todella suuri osa \gls{domainmodel}
koostuu juuri \gls{entity}stä.

Tärkeä osa mallia ovat myös kulkusuunnat \gls{entity} välillä. Nämä
vaikuttavat paitsi ohjelmiston tekniseen monimutkaisuuteen, myös siihen,
minkälaisia asioita mallilla on mahdollista ilmaista.

Esimerkiksi lasku voi koostua joukosta laskurivejä. Ohjelman toteutus ja
käyttötavat muuttuvat hyvin paljon, jos kulkusuuntaa muutetaan.
Ensimmäisessä tapauksessa lasku tietää, mitkä laskurivit siihen
kuuluvat, mutta yksittäinen laskurivi ei tiedä, miltä laskulta on
peräisin. Toisessa tapauksessa laskurivi osaa kertoa, mille laskulle se
kuuluu, mutta lasku ei kykene listaamaan omia rivejään. Mikäli näiden
kahden käsitteen välillä kulkeminen onnistuu molempiin suuntiin,
ohjelman monimutkaisuus kasvaa.

\hypertarget{graphql}{%
\subsection{GraphQL}\label{graphql}}

\hypertarget{tyyppijuxe4rjestelmuxe4}{%
\subsubsection{Tyyppijärjestelmä}\label{tyyppijuxe4rjestelmuxe4}}

GraphQL-rajapinta koostuu tyypeistä, joiden avulla rajapinnalle
lähetetään kysely. Rajapinta palauttaa takaisin oliota edustavan joukon
kenttiä avain-arvo -pareina. \cite{graphql:spec}

Oheisessa esimerkissä kuvataan tyyppien, ja sitä myötä olioiden väliset
suhteet. ConsolidatedInvoice-tyyppisessä oliossa on sisällä
invoices-kenttä, joka on lista Invoice-tyyppisiä olioita.

\begin{verbatim}
type Query {
  consolidatedInvoices [ConsolidatedInvoice]
}

Type Invoice {
  number: Int
  sum: Float
  date: Date
}

type ConsolidatedInvoice {
  number: Int
  invoices: [Invoice]
}
\end{verbatim}

\hypertarget{skeema}{%
\subsubsection{Skeema}\label{skeema}}

Rajapinnan tyypit, niille tehtävät kyselyt ja mutaatiot kuvataan
skeemassa, GraphQL-kielen avulla. ConsolidatedInvoice- ja
Invoice-olioista koostuva esimerkki on validi GraphQL-skeema.

GraphQL-kehityksessä tyylejä on useita, ja yksi suosittu tapa on
kirjoittaa skeema ensiksi. Se tarjoaa suuntaviivat sekä rajapinnan
tekniselle toteutukselle, että myös graafisen asiakasohjelman
laatimiselle.

\hypertarget{query-ja-mutation}{%
\subsubsection{Query ja Mutation}\label{query-ja-mutation}}

Rajapintaan voi tehdä kyselyjä Query-tyyppisen juuriolion kautta. Tämän
olion kentät vastaavat käytännössä niitä kyselyitä, joita rajapintaan
voi tehdä. Kentät ovat ikäänkuin sisäänmenoaukkoja, joiden kautta
oliorakenteita voi pyytää.

Kun oheisen esimerkin mukaisesti määritellystä GraphQL-rajapinnasta
halutaan pyytää tietoja, tehdään kysely, joka kuvaa halutun oliopuun
rakenteen tyyppien avulla:

\begin{verbatim}
{
  ConsolidatedInvoice {
    number
    invoices {
      number
      sum
    }
  }
}
\end{verbatim}

Kyselyssä määritellään kentät, jotka palautuvassa datassa halutaan
nähdä. Näin myös oliopuun syvyyttä voidaan kontrolloida. Oheisessa
esimerkissä voidaan hakea paitsi lista koontilaskuista, haluttaessa myös
jokaisen koontilaskun alle lista siihen kuuluvista laskuista.

Mutation-juurityyppiä puolestaan käytetään datan muunnoksiin.
Mutation-komennot voivat myös palauttaa oliorakenteita.
